<!doctype html>
<html lang="en">
<head>
  <title>CS Conference Twitter Bot</title>
  {{{headerHtml}}}
</head>
<script>
  //@ts-check
  function paperDetails(d) {
    selectedPaper = d;
    if (!d.fullAbstract) {
      getFullAbstract(d);
    }

    const content = renderPaper(d, $('#picture-tpl').val());

    const paper = `
    <div id="paper-${d.id}">
      <div class="p-details" contenteditable="true">${content}</div>
    </div>`;
    return $(paper);
  }

  async function renderPaperDetails(paper) {
    if (!paper.fullAbstract) {
      const response = await fetch(`/paper/${paper.id}`);
      paper = await response.json();
    }

    const content = renderPaper(paper, $('#picture-tpl').val());

    $('#render-image').html(
      `<div class="p-details">${content}</div>`);
    const detailsJQDiv = $('#render-image .p-details');
    const dataUrl = await renderDivToImage(detailsJQDiv[0]);
    detailsJQDiv.remove();
    return dataUrl;
  }

  async function getFullAbstract(d) {
    const response = await fetch(`/paper/${d.id}`);
    const paper = await response.json();

    $(`#paper-${d.id} .p-abstract`).html(paper.fullAbstract);
  }

  let paperTable = null;
  let selectedPaper = null;

  function showInQueue(tweetText, dataUrl, paperId) {
    $("#tweet-queue").append(`
      <div class="tw-queue-item" id="tweet-for-paper-${paperId}">
        <div class="tw-queue-text">${tweetText}</div>
        <div class="tw-queue-img"><img src="${dataUrl}"></div>
      </div>
    `);
  }

  async function queueTweet() {
    if (!selectedPaper) {
      return;
    }

    const dataUrl = await renderPaperDetails(selectedPaper);
    const tweetText = $('#tweet').val();
    const id = selectedPaper.id;

    showInQueue(tweetText, dataUrl, id);

    const response = await fetch('/queue-tweet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: tweetText,
        image: dataUrl,
        paperId: id
      })
    });
    const result = await response.json();
  }

  async function renderToImage() {
    const detailsDiv = $(`#paper-${selectedPaper.id} .p-details`)[0]
    return await renderDivToImage(detailsDiv);
  }

  async function renderDivToImage(div) {
    try {
      const canvas = await html2canvas(div);
      const dataUrl = canvas.toDataURL();
      return dataUrl;
    } catch (error) {
      console.error('Error when rending abstract to image for twitter', error);
    };
  }

  function togglePaperDetails() {
    const tr = $(this).closest('tr');
    const row = paperTable.row(tr);
    if (!row.data()) {
      return;
    }

    if (row.child.isShown()) {
      row.child.hide();
      tr.removeClass('shown');
    } else {
      const detailsElem = paperDetails(row.data());
      row.child(detailsElem).show();
      tr.addClass('shown');
    }
  }

  function togglePaperSelected() {
    if ($(this).hasClass('selected')) {
      $(this).removeClass('selected');
    } else {
      const tr = $(this).closest('tr');
      const row = paperTable.row(tr);

      if (!row.data()) {
        return;
      }

      paperTable.$('tr.selected').removeClass('selected');
      $(this).addClass('selected');
      renderPaperInTemplate(row.data());
    }
  }

  function renderPaperInTemplate(paper) {
    selectedPaper = paper;
    const tweet = renderPaper(paper, $('#tweet-tpl').val());
    $('#tweet').val(tweet);
    tweetLength();
  }

  function renderPaper(paper, template) {
    if (template && template.length > 0) {
      const p = {...paper};
      if (p.fullAbstract) {
        p.abstract = p.fullAbstract;
      } else {
        p.abstract = p.shortAbstract;
      }

      p.fullAuthors = p.authors.join(', ');

      return Mustache.render(template, p);
    }
    return '';
  }

  function createTable(data) {
    return $('#papers').DataTable({
      columns: [
        {
          className: 'dt-control',
          orderable: false,
          data: null,
          defaultContent: ''
        },
        {title: "Title",    data: 'title'},
        {title: "Type",     data: 'type',    visible: false},
        {title: "URL",      data: 'url',     visible: false},
        {title: "Authors",  data: d => d.authors.join(', ')},
        {title: "Month",    data: d => d.monthYear.split(' ')[0]},
        {title: "Year",     data: d => d.monthYear.split(' ')[1]},
        {title: "Pages",    data: 'pages',   visible: false},
        {title: "Abstract", data: 'shortAbstract', visible: false},
        {title: "Cites",    data: 'citations'},
        {title: "#Down",    data: 'downloads'}
      ],
      data: data
    });
  }

  async function loadPapers() {
    const urls = $('#urls').text().trim();
    const response = await fetch('/load-urls', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({urls})
    });

    const data = await response.json();

    paperTable?.destroy();
    paperTable = createTable(data.papers);

    // Add event listener for opening and closing details
    $('#papers tbody').on('click', 'td.dt-control', togglePaperDetails);
    $('#papers tbody').on('click', 'tr', togglePaperSelected);
  }

  async function loadTweets() {
    const response = await fetch('/load-queue');
    const data = await response.json();
    if (data.tweets) {
      for (const tweet of data.tweets) {
        showInQueue(tweet.text, tweet.image, tweet.paperId);
      }
    }
  }

  async function loadConfig() {
    const response = await fetch('/configuration');
    const data = await response.json();

    $('#tweet-tpl').val(data?.tweetTpl);
    $('#picture-tpl').val(data?.pictureTpl);
    $('#picture-style').val(data?.pictureStyle);
    $('#tweet-pic-style').text(data?.pictureStyle);
  }

  async function saveAndApplyConfig() {
    const tweetTpl = $('#tweet-tpl').val();
    const pictureTpl = $('#picture-tpl').val();
    const pictureStyle = $('#picture-style').val();

    $('#tweet-pic-style').text(pictureStyle);

    const response = await fetch('/configuration', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        tweetTpl, pictureTpl, pictureStyle
      })
    });
    const data = await response.json();
  }

  function tweetLength() {
    const maxTweetLength = 280;
    let length = $('#tweet').val().length;
    $('#tweet-length').text(`${length} / ${maxTweetLength}`);

    length = $('#tweet-tpl').val().length;
    $('#tweet-tpl-length').text(`${length} / ${maxTweetLength}`);
  }

  $(async function(){
    $('#load-btn').click(loadPapers);
    $('#save-config-btn').click(saveAndApplyConfig);
    $('#tweet').keyup(tweetLength);
    $('#tweet-tpl').keyup(tweetLength);
    $('#queue-btn').click(queueTweet);

    loadTweets();
    await loadConfig();
    tweetLength();
  });
</script>
<body>

<form>
  <div class="form-group">
    <label for="urls">URLs to ACM DL Proceeding Pages</label>
    <textarea class="form-control" id="urls" rows="3">
https://dl.acm.org/doi/proceedings/10.1145/3475738
https://dl.acm.org/doi/proceedings/10.1145/3426182
https://dl.acm.org/doi/proceedings/10.1145/3357390
https://dl.acm.org/doi/proceedings/10.1145/3237009
https://dl.acm.org/doi/proceedings/10.1145/3132190
https://dl.acm.org/doi/proceedings/10.1145/2972206
https://dl.acm.org/doi/proceedings/10.1145/2807426
https://dl.acm.org/doi/proceedings/10.1145/2647508
https://dl.acm.org/doi/proceedings/10.1145/2500828
https://dl.acm.org/doi/proceedings/10.1145/2093157
https://dl.acm.org/doi/proceedings/10.1145/1852761
https://dl.acm.org/doi/proceedings/10.1145/1596655
https://dl.acm.org/doi/proceedings/10.1145/1411732
https://dl.acm.org/doi/proceedings/10.1145/1294325
https://dl.acm.org/doi/proceedings/10.1145/1168054
https://dl.acm.org/doi/proceedings/10.5555/1071565
https://dl.acm.org/doi/proceedings/10.5555/957289
https://dl.acm.org/doi/proceedings/10.5555/638476
    </textarea>
  </div>
  <button type="button" id="load-btn" class="btn btn-primary mb-2">Load</button>
</form>

<table id="papers"></table>


<form>
  <textarea class="form-control" id="tweet" rows="6"></textarea>
  <span class="float-right badge badge-secondary" id="tweet-length"></span>
  <button type="button" class="btn btn-outline-info" id="queue-btn">Queue Tweet</button>
</form>

<h3>Templates</h3>
<form>
  <label for="tweet-tpl">Tweet Template</label>
  <textarea class="form-control" id="tweet-tpl" rows="6"></textarea>
  <span class="float-right badge badge-secondary" id="tweet-tpl-length"></span>

  <label for="picture-tpl">Tweet Picture Template</label>
  <textarea class="form-control" id="picture-tpl" rows="8"></textarea>

  <label for="picture-style">Tweet Picture CSS Style</label>
  <textarea class="form-control" id="picture-style" rows="8"></textarea>

  <button type="button" id="save-config-btn" class="btn btn-primary mb-2">Save &amp; Apply</button>
</form>

<h3>Tweet Queue</h3>

<div id="tweet-queue"></div>


<h2>TODO</h2>
<pre>
[x] 1. Table of papers
[x]   - parse ACM DL overview page
[x]   - save data into JSON file
[x]   - load data into table

[x] 2. Tweet Composer
[x]  - have preview window, with data from table
[x]  - have template window, with template from file, or json storage or so

[-] 3. Screenshot of Paper or Abstract and Conf Info
[x]  - parse ACM DL paper pages to get full abstract
[-]  - load PDF
[-]  - PDF to PND or so
[-]  - select part of paper to use
[x]  - generate image for use on Twitter from paper data, incl. abstract
[x]  - allow to include some conference ad/notes/deadlines

[x] 4. Store Tweets for later sending
[x]  - save tweet text and rendered abstract image
[x]  - show all saved tweets
[x]  - convert dataUrl to PNG

[ ] 5. Tweet
[ ]  - connect to twitter and send tweet

[ ] 6. Database of Author Twitter Handles
[ ]   - keep author name/email twitter handle mapping
[ ]   - automatically search twitter for possible matches

[ ] 7. Tweet Schedule/Tweet Queue
[ ]   - list of prepared/saved tweets
[ ]	  - schedule them every 2nd, 3rd day, or every week
[ ]	  - have server send them at the given time

[ ] 8. Store changed title/authors, etc
[ ]   - the abstract bit is editable, so, would be good to store the changed bits

</pre>
<div id="render-image"></div>
</body>
</html>
